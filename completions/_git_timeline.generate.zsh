## Generate the _git_timeline Zsh completion file.
##
## Usage: zsh _git_timeline.generate.zsh > _git_timeline
##
## Outputs the generated _git_timeline completion function to stdout.
## The caller is responsible for placing the file in a directory on $fpath.
##
## How 'git timeline --<Tab>' works:
##
## The existing _git Zsh completion from:
## > https://github.com/git/git/blob/master/contrib/completion/git-completion.zsh
## handles 'git <sub>' completions. When the subcommand is 'timeline', it looks up
## _git_timeline() in $functions and calls it. _git_timeline() sources git-completion.bash
## (already present on the system as part of a standard git install) and delegates to
## _git_log, giving identical completions to 'git log'.
##
## Caveats:
##
## If 'git timeline --<TAB>' completions do not work, add this line to ~/.zshrc:
##   zstyle ':completion:*:*:git:*' script \
##     $(brew --prefix)/share/zsh/site-functions/git-completion.bash
## The issue usually is that git-completion.bash is not in the same directory as _git.
## Running 'brew reinstall git' often fixes this — check its Caveats output for the
## completions directory. If git-completion.bash is not alongside _git, you need the
## zstyle line above.
##
## After upgrading Git, re-run to sync with the new version:
##   zsh _git_timeline.generate.zsh > _git_timeline

setopt ERR_EXIT

# 1. DETECT GIT VERSION
# ---

if (( ! $+commands[git] )); then
    echo "ERROR: git is not installed or not in PATH" >&2
    exit 1
fi

# Strip OS-specific suffixes (e.g. "(Apple Git-130)" on macOS)
git_version=$(git --version | sed 's/^git version //' | awk '{print $1}')
if [[ -z "$git_version" ]]; then
    echo "ERROR: Could not parse git version from 'git --version'" >&2
    exit 1
fi

# 2. LOCATE git-completion.bash
# ---
# Determine the installation method from the git executable path, then check
# the known candidate locations for that method. First match wins.

git_path=$(which git)
local bash_completion_script=""
local zstyle_script=""

if [[ "$git_path" == "$(brew --prefix)/bin/git" ]]; then
    local brew_candidates=(
        "$(brew --prefix)/share/zsh/site-functions/git-completion.bash"
    )
    for candidate in "${brew_candidates[@]}"; do
        if [[ -f "$candidate" ]]; then
            bash_completion_script="$candidate"
            zstyle_script='$(brew --prefix)/share/zsh/site-functions/git-completion.bash'
            break
        fi
    done
    if [[ -z "$bash_completion_script" ]]; then
        echo "ERROR: git-completion.bash not found. Searched:" >&2
        for candidate in "${brew_candidates[@]}"; do
            echo "  $candidate" >&2
        done
        echo "Try: brew reinstall git" >&2
        exit 1
    fi
else
    echo "ERROR: Unsupported git installation: $git_path" >&2
    echo "Only Homebrew git is currently supported." >&2
    exit 1
fi

# 3. DOWNLOAD git-completion.zsh (temporary, for awk extraction only)
# ---
# git-completion.zsh is not installed locally by Homebrew. We download it
# temporarily to extract the __gitcomp* wrapper functions via awk. The file
# is cleaned up on exit and never installed anywhere.

base_url="https://raw.githubusercontent.com/git/git/v${git_version}/contrib/completion"
zsh_url="${base_url}/git-completion.zsh"

temp_dir=$(mktemp -d)
trap "rm -rf $temp_dir" EXIT

if ! curl -fsSL "$zsh_url" -o "$temp_dir/git-completion.zsh" 2>/dev/null; then
    echo "ERROR: Failed to download git-completion.zsh" >&2
    echo "  URL: $zsh_url" >&2
    echo "" >&2
    echo "Possible causes:" >&2
    echo "  - No internet connection" >&2
    echo "  - Git version v${git_version} not found on GitHub" >&2
    echo "    (Some OS-bundled git versions use non-standard version strings)" >&2
    echo "" >&2
    echo "Try: curl -I $zsh_url" >&2
    exit 1
fi

# 4. GENERATE _git_timeline (stdout)
# ---
# '#compdef -' tells compinit to autoload this file as a function stub without
# binding it to any command. This makes _git_timeline() available in $functions
# from shell init, so the _git bridge's __git_complete_command() can find and
# call it when completing 'git timeline --<TAB>'.
#
# The function uses git's zsh-to-bash bridge pattern from git-completion.zsh:
#   1. Source git-completion.bash (GIT_SOURCING_ZSH_COMPLETION=y suppresses
#      bash 'complete' registrations that are no-ops in zsh)
#   2. Define zsh wrapper functions (__gitcomp* etc.) copied verbatim from
#      git-completion.zsh — these translate bash completion output to zsh compadd
#   3. Set up bash-style cursor variables (cur/cword/prev) from zsh's 1-indexed
#      CURRENT/words[] before ksh emulation switches arrays to 0-indexed
#   4. Call _git_log via 'emulate ksh -c' for bash/ksh compatibility

cat << HEADER
#compdef -

# Generated by _git_timeline.generate.zsh
# See: https://github.com/hernancerm/git-timeline/tree/main/completions
#
# Git version: ${git_version}
#
# '#compdef -' causes compinit to register this file as an autoloadable
# function stub without binding it to any command. After 'exec zsh', the
# _git completion bridge finds _git_timeline() in \$functions and calls it
# when completing 'git timeline --<TAB>'.

# STEP 1: Source git-completion.bash
# ---
# Path evaluated at completion time. GIT_SOURCING_ZSH_COMPLETION=y tells
# git-completion.bash it is running in a zsh context; 'complete' is
# neutralised so bash registration calls are no-ops.

local script="${zstyle_script}"
if [[ ! -f "\$script" ]]; then
    _message "git-completion.bash not found at \$script; run: zsh _git_timeline.generate.zsh > _git_timeline"
    return 1
fi
local old_complete="\$functions[complete]"
functions[complete]=:
GIT_SOURCING_ZSH_COMPLETION=y . "\$script"
functions[complete]="\$old_complete"

# STEP 2: Zsh-compatible wrappers for bash completion primitives
# ---
# Copied verbatim from git-completion.zsh v${git_version} (official git source).
# These translate bash COMPREPLY / __gitcomp calls into zsh compadd calls.

HEADER

# Append __gitcomp* wrappers: everything from __gitcomp() up to _git_zsh()
awk '
    /^__gitcomp \(\)/  { printing=1 }
    /^_git_zsh \(\)/   { exit }
    printing           { print }
' "$temp_dir/git-completion.zsh"

# Validate that the expected wrapper functions were actually extracted.
# If git ever renames or restructures these, fail loudly rather than silently
# producing a broken completion file.
for fn in __gitcomp __gitcomp_direct __gitcomp_nl __gitcomp_file; do
    if ! awk "/^${fn} \(\)/{found=1} END{exit !found}" "$temp_dir/git-completion.zsh"; then
        echo "ERROR: Failed to extract ${fn}() from git-completion.zsh v${git_version}" >&2
        echo "  The structure of git-completion.zsh may have changed in this version." >&2
        echo "  Please file an issue at https://github.com/hernancerm/git-timeline" >&2
        exit 1
    fi
done

cat << 'FOOTER'

# STEP 3: Entry point
# ---
# Set up bash-style cursor variables while still in zsh context (1-indexed
# arrays). CURRENT is a zsh 1-based index; words[CURRENT] is the word under
# the cursor. These must be captured before ksh emulation switches arrays to
# 0-indexed — otherwise words[CURRENT] is out of bounds and cur="".
#
# Then call _git_log via 'emulate ksh -c' (not 'emulate -L ksh' at function
# top) so the locals set above remain visible inside _git_log.

local cur cword prev
local __git_repo_path
local __git_cmd_idx=1

cur=${words[CURRENT]}
prev=${words[CURRENT-1]}
let cword=CURRENT-1

emulate ksh -c _git_log
FOOTER
